-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Replacement base module for CodeWorld
--   
--   This module replaces base when building CodeWorld apps. It simplifies
--   the Haskell Prelude to remove the use of numeric type classes and
--   unify some types.
@package codeworld-base
@version 0.1.0.0


-- | The standard set of functions and variables available to all programs.
--   
--   You may use any of these functions and variables without defining
--   them.
module Prelude

-- | The type for numbers.
--   
--   Numbers can be positive or negative, whole or fractional. For example,
--   5, 3.2, and -10 are all values of the type Number.
data Number

-- | Adds two numbers.
(+) :: Number -> Number -> Number

-- | Subtracts two numbers.
(-) :: Number -> Number -> Number

-- | Multiplies two numbers.
(*) :: Number -> Number -> Number

-- | Divides two numbers. The second number should not be zero.
(/) :: Number -> Number -> Number

-- | Raises a number to a power.
(^) :: Number -> Number -> Number

-- | Tells whether one number is greater than the other.
(>) :: Number -> Number -> Truth

-- | Tells whether one number is greater than or equal to the other.
(>=) :: Number -> Number -> Truth

-- | Tells whether one number is less than the other.
(<) :: Number -> Number -> Truth

-- | Tells whether one number is less than or equal to the other.
(<=) :: Number -> Number -> Truth

-- | Gives the larger of two numbers.
max :: (Number, Number) -> Number

-- | Gives the smaller of two numbers.
min :: (Number, Number) -> Number

-- | Gives the opposite (that is, the negative) of a number.
opposite :: Number -> Number
negate :: Number -> Number

-- | Gives the absolute value of a number.
--   
--   If the number if positive or zero, the absolute value is the same as
--   the number. If the number is negative, the absolute value is the
--   opposite of the number.
abs :: Number -> Number
absoluteValue :: Number -> Number

-- | Gives the sign of a number.
--   
--   If the number is negative, the signum is -1. If it's positive, the
--   signum is 1. If the number is 0, the signum is 0. In general, a number
--   is equal to its absolute value (<a>abs</a>) times its sign
--   (<a>signum</a>).
signum :: Number -> Number

-- | Gives the number without its fractional part.
--   
--   For example, truncate(4.2) is 4, while truncate(-4.7) is -4.
truncation :: Number -> Number

-- | Gives the number rounded to the nearest integer.
--   
--   For example, round(4.2) is 4, while round(4.7) is 5.
rounded :: Number -> Number

-- | Gives the smallest integer that is greater than or equal to a number.
--   
--   For example, ceiling(4) is 4, while ceiling(4.1) is 5. With negative
--   numbers, ceiling(-3.5) is -3, since -3 is greater than -3.5.
ceiling :: Number -> Number

-- | Gives the largest integer that is less than or equal to a number.
--   
--   For example, floor(4) is 4, while floor(3.9) is 3. With negative
--   numbers, floor(-3.5) is -4, since -4 is less than -3.5.
floor :: Number -> Number

-- | Gives the integer part of the result when dividing two numbers.
--   
--   For example, 3/2 is 1.5, but quotient(3, 2) is 1, which is the integer
--   part.
quotient :: (Number, Number) -> Number

-- | Gives the remainder when dividing two numbers.
--   
--   For example, remainder(3,2) is 1, which is the remainder when dividing
--   3 by 2.
remainder :: (Number, Number) -> Number

-- | Gives the repicrocal of a number.
--   
--   For example, reciprocal(5) is 1/5 (also written as 0.2).
reciprocal :: Number -> Number

-- | The constant pi, which is equal to the ration between the
--   circumference and diameter of a circle.
--   
--   pi is approximately 3.14159.
pi :: Number

-- | Gives the exponential of a number. This is equal to the constant e,
--   raised to the power of the number.
--   
--   The exp function increases faster and faster very quickly. For
--   example, if t is the current time in seconds, exp(t) will reach a
--   million in about 14 seconds. It will reach a billion in around 21
--   seconds.
exp :: Number -> Number

-- | Gives the square root of a number. This is the positive number that,
--   when multiplied by itself, gives the original number back.
--   
--   The sqrt always increases, but slows down. For example, if t is the
--   current time, sqrt(t) will reach 5 in 25 seconds. But it will take 100
--   seconds to reach 10, and 225 seconds (almost 4 minutes) to reach 15.
sqrt :: Number -> Number
squareRoot :: Number -> Number

-- | Gives the natural log of a number. This is the opposite of the exp
--   function.
--   
--   Like sqrt, the log function always increases, but slows down. However,
--   it slows down much sooner than the sqrt function. If t is the current
--   time in seconds, it takes more than 2 minutes for log(t) to reach 5,
--   and more than 6 hours to reach 10!
log :: Number -> Number

-- | Gives the logarithm of the first number, using the base of the second
--   number.
logBase :: (Number, Number) -> Number

-- | Gives the sine of an angle, where the angle is measured in degrees.
sin :: Number -> Number

-- | Gives the tangent of an angle, where the angle is measured in degrees.
--   
--   This is the slope of a line at that angle from horizontal.
tan :: Number -> Number

-- | Gives the cosine of an angle, where the angle is measured in degrees.
cos :: Number -> Number

-- | Gives the inverse sine of a value, in degrees.
--   
--   This is the unique angle between -90 and 90 that has the input as its
--   sine.
asin :: Number -> Number

-- | Gives the inverse tangent of a value, in degrees.
--   
--   This is the unique angle between -90 and 90 that has the input as its
--   tangent.
atan :: Number -> Number

-- | Gives the angle between the positive x axis and a given point, in
--   degrees.
atan2 :: (Number, Number) -> Number

-- | Gives the inverse cosine of a value, in degrees.
--   
--   This is the unique angle between 0 and 180 that has the input as its
--   cosine.
acos :: Number -> Number

-- | Separates a number into its whole and fractional parts.
--   
--   For example, properFraction(1.2) is (1, 0.2).
properFraction :: Number -> (Number, Number)

-- | Tells if a number is even.
even :: Number -> Truth

-- | Tells if a number is odd.
odd :: Number -> Truth

-- | Gives the greatest common divisor of two numbers.
--   
--   This is the largest number that divides each of the two parameters.
--   Both parameters must be integers.
gcd :: (Number, Number) -> Number

-- | Gives the least common multiple of two numbers.
--   
--   This is the smallest number that is divisible by both of the two
--   parameters. Both parameters must be integers.
lcm :: (Number, Number) -> Number

-- | Gives the sum of a list of numbers.
sum :: [Number] -> Number

-- | Gives the product of a list of numbers.
product :: [Number] -> Number

-- | Gives the largest number from a list.
maximum :: [Number] -> Number

-- | Gives the smallest number from a list.
minimum :: [Number] -> Number

-- | Tells whether a Number is an integer or not.
--   
--   An integer is a whole number, such as 5, 0, or -10. Numbers with
--   non-zero decimals, like 5.3, are not integers.
isInteger :: Number -> Truth
fromInteger :: Integer -> Number
fromRational :: Rational -> Number
fromInt :: Int -> Number
toInt :: Number -> Int
fromDouble :: Double -> Number
toDouble :: Number -> Double
data Text
fromString :: String -> Text
toString :: Text -> String
fromCWText :: Text -> Text
toCWText :: Text -> Text
(<>) :: Text -> Text -> Text
numberOfCharacters :: Text -> Number
numberOfWords :: Text -> Number
numberOfLines :: Text -> Number
lines :: Text -> [Text]
unlines :: [Text] -> Text
words :: Text -> [Text]
unwords :: [Text] -> Text
characters :: Text -> [Text]
printed :: Number -> Text
joined :: [Text] -> Text
joinedWith :: ([Text], Text) -> Text
lowercase :: Text -> Text
uppercase :: Text -> Text
capitalized :: Text -> Text
startsWith :: (Text, Text) -> Truth
endsWith :: (Text, Text) -> Truth

-- | Gives the result of replacing one piece of text with another.
--   
--   For example, `substitution("How do you do?", "do", "be")` is equal to
--   `"How be you be?"`.
substitution :: (Text, Text, Text) -> Text

-- | Gives the result of performing many substitutions in a piece of text.
--   This is commonly used to build text to show in a program, as in this
--   example:
--   
--   substitutions("Lives: [lives] of 3 Score: [score]", [("[lives]",
--   printed(lives)), ("[score]", printed(score))])
substitutions :: (Text, [(Text, Text)]) -> Text
ifThenElse :: Truth -> a -> a -> a

-- | Compares values to see if they are equal.
(==) :: a -> a -> Truth

-- | Compares values to see if they are not equal. Note that `a /= b` is
--   the same as `not (a == b)`.
(/=) :: a -> a -> Truth
type Truth = Bool
data Bool :: *
False :: Bool
True :: Bool
(&&) :: Truth -> Truth -> Truth
(||) :: Truth -> Truth -> Truth
not :: Truth -> Truth
otherwise :: Truth

-- | Converts a function to an operator.
--   
--   Example use:
--   
--   f(x,y) = 2*x + y (%) = toOperator(f)
--   
--   eight = 3 % 2
--   
--   This has the same effect as defining % as:
--   
--   x % y = 2*x + y eight = 3 % 2
toOperator :: ((a, b) -> c) -> (a -> b -> c)

-- | Converts an operator into a normal function.
--   
--   Example use:
--   
--   divide = fromOperator(/) four = divide(16, 4)
fromOperator :: (a -> b -> c) -> ((a, b) -> c)

-- | Identity function.
id :: a -> a

-- | Function composition.
(.) :: (b -> c) -> (a -> b) -> a -> c

-- | Returns the first element of an ordered pair.
firstOfPair :: (a, b) -> a

-- | Returns the second element of an ordered pair.
secondOfPair :: (a, b) -> b

-- | Fails with an error message.
error :: Text -> a

-- | A special case of <a>error</a>. It is expected that compilers will
--   recognize this and insert error messages which are more appropriate to
--   the context in which <a>undefined</a> appears.
undefined :: a

-- | Append two lists, i.e.,
--   
--   <pre>
--   [x1, ..., xm] ++ [y1, ..., yn] == [x1, ..., xm, y1, ..., yn]
--   [x1, ..., xm] ++ [y1, ...] == [x1, ..., xm, y1, ...]
--   </pre>
--   
--   If the first list is not finite, the result is the first list.
(++) :: [a] -> [a] -> [a]

-- | Determines whether a list is empty or not.
empty :: [a] -> Truth

-- | Determines whether a value is a member of a list or not.
contains :: ([a], a) -> Truth

-- | Gives the length of a list.
length :: [a] -> Number

-- | Gives the member of a list at a given index. Indices start at 0.
at :: ([a], Number) -> a

-- | Gives the member of a list at a given index. Indices start at 0.
(#) :: [a] -> Number -> a

-- | Determines if any proposition in a list is true.
--   
--   For example, `any([even(n) | n &lt;- [1,2,3]])` is <tt>True</tt>,
--   because 2 is even.
any :: [Truth] -> Truth

-- | Determines if all propositions in a list are true.
--   
--   For example, `all([even(n) | n &lt;- [2,3,4]])` is <tt>False</tt>,
--   because 3 is not even.
all :: [Truth] -> Truth

-- | Determines if all propositions in a list are false.
--   
--   For example, `none([odd(n) | n &lt;- [2,3,4]])` is <tt>False</tt>,
--   because 3 is odd.
none :: [Truth] -> Truth

-- | Forms a list by repeating a source list some number of times.
repeated :: ([a], Number) -> [a]

-- | Forms a list by repeating a source list forever.
repeating :: [a] -> [a]

-- | Gives the first members of a list, up to the given number.
first :: ([a], Number) -> [a]

-- | Gives the last members of a list, up to the given number.
last :: ([a], Number) -> [a]

-- | Gives all members of a list after the given number.
--   
--   In general, `xs = first(xs, n) ++ rest(xs, n)`.
rest :: ([a], Number) -> [a]

-- | Gives the longest prefix of a list for which a condition is true.
--   
--   For example, `while([2,4,5,6], even) = [2,4]`.
while :: ([a], a -> Truth) -> [a]

-- | Gives the longest prefix of a list for which a condition is false.
--   
--   For example, `until([2,4,5,6], odd) = [2,4]`.
until :: ([a], a -> Truth) -> [a]

-- | Gives the remaining portion of a list after the longest prefix for
--   which a condition is true.
--   
--   In general, `xs = while(xs, cond) ++ after(xs, cond)
after :: ([a], a -> Truth) -> [a]

-- | Gives the concatenation of all of the lists in its input.
concatenation :: [[a]] -> [a]

-- | The <a>subsequences</a> function returns the list of all subsequences
--   of the argument.
--   
--   <pre>
--   subsequences "abc" == ["","a","b","ab","c","ac","bc","abc"]
--   </pre>
subsequences :: [a] -> [[a]]

-- | The <a>permutations</a> function returns the list of all permutations
--   of the argument.
--   
--   <pre>
--   permutations "abc" == ["abc","bac","cba","bca","cab","acb"]
--   </pre>
permutations :: [a] -> [[a]]

-- | Gives a list of numbers reordered into increasing order.
sorted :: [Number] -> [Number]

-- | Gives a list in the opposite order of the original.
reversed :: [a] -> [a]

-- | Gives a list with all duplicate members removed.
unique :: [a] -> [a]
transposed :: [[a]] -> [[a]]

-- | Combines a list of values into a single value, by merging members with
--   a function. The function should take two parameters, and should be
--   associative (so `f(x,f(y,z)) = f(f(x,y),z)`). The list should be
--   non-empty.
--   
--   For example, `combined(fromOperator(+), [1, 3, 5])` is equal to `9`.
combined :: ((a, a) -> a, [a]) -> a

-- | The <a>Maybe</a> type encapsulates an optional value. A value of type
--   <tt><a>Maybe</a> a</tt> either contains a value of type <tt>a</tt>
--   (represented as <tt><a>Just</a> a</tt>), or it is empty (represented
--   as <a>Nothing</a>). Using <a>Maybe</a> is a good way to deal with
--   errors or exceptional cases without resorting to drastic measures such
--   as <a>error</a>.
--   
--   The <a>Maybe</a> type is also a monad. It is a simple kind of error
--   monad, where all errors are represented by <a>Nothing</a>. A richer
--   error monad can be built using the <a>Either</a> type.
data Maybe a :: * -> *
Nothing :: Maybe a
Just :: a -> Maybe a

-- | Converts a Maybe value to a plain value, by using a default.
--   
--   For example, `withDefault(Nothing, 5)` is equal to 5, while
--   `withDefault(Just(3), 5)` is equal to 3.
withDefault :: (Maybe a, a) -> a

-- | Determines if a Maybe has a value.
hasValue :: Maybe a -> Truth

-- | Extracts the value from a Maybe, and crashes the program if there is
--   no such value.
definitely :: Maybe a -> a
fromRandomSeed :: Number -> [Number]
shuffled :: ([a], Number) -> [a]

-- | A value of type <tt><a>IO</a> a</tt> is a computation which, when
--   performed, does some I/O before returning a value of type <tt>a</tt>.
--   
--   There is really only one way to "perform" an I/O action: bind it to
--   <tt>Main.main</tt> in your program. When your program is run, the I/O
--   will be performed. It isn't possible to perform I/O from an arbitrary
--   function, unless that function is itself in the <a>IO</a> monad and
--   called at some point, directly or indirectly, from <tt>Main.main</tt>.
--   
--   <a>IO</a> is a monad, so <a>IO</a> actions can be combined using
--   either the do-notation or the <tt>&gt;&gt;</tt> and <tt>&gt;&gt;=</tt>
--   operations from the <tt>Monad</tt> class.
data IO a :: * -> *

-- | The type for numbers.
--   
--   Numbers can be positive or negative, whole or fractional. For example,
--   5, 3.2, and -10 are all values of the type Number.
data Number
data Text
newtype Color
RGBA :: (Number, Number, Number, Number) -> Color
type Colour = Color
black :: Color
white :: Color
red :: Color
green :: Color
blue :: Color
cyan :: Color
magenta :: Color
yellow :: Color
aquamarine :: Color
orange :: Color
azure :: Color
violet :: Color
chartreuse :: Color
rose :: Color
brown :: Color
pink :: Color
purple :: Color
gray :: Number -> Color
grey :: Number -> Color
mixed :: (Color, Color) -> Color
lighter :: (Color, Number) -> Color
light :: Color -> Color
darker :: (Color, Number) -> Color
dark :: Color -> Color
brighter :: (Color, Number) -> Color
bright :: Color -> Color
duller :: (Color, Number) -> Color
dull :: Color -> Color
translucent :: Color -> Color
hue :: Color -> Number
saturation :: Color -> Number
luminosity :: Color -> Number
fromHSL :: (Number, Number, Number) -> Color
type Point = (Number, Number)
type Vector = (Number, Number)
vectorSum :: (Vector, Vector) -> Vector
vectorDifference :: (Vector, Vector) -> Vector
scaledVector :: (Vector, Number) -> Vector
rotatedVector :: (Vector, Number) -> Vector
dotProduct :: (Vector, Vector) -> Number
data Picture
data Font
Serif :: Font
SansSerif :: Font
Monospace :: Font
Handwriting :: Font
Fancy :: Font
NamedFont :: !Text -> Font
data TextStyle
Plain :: TextStyle
Italic :: TextStyle
Bold :: TextStyle

-- | A blank picture
blank :: Picture

-- | A thin sequence of line segments with these endpoints
path :: [Point] -> Picture

-- | A thin sequence of line segments, with these endpoints and line width
thickPath :: ([Point], Number) -> Picture

-- | A thin line with these points as endpoints
line :: [Point] -> Picture

-- | A thick line, with these endpoints, with this line width
thickLine :: ([Point], Number) -> Picture

-- | A thin polygon with these points as vertices
polygon :: [Point] -> Picture

-- | A thin polygon with these points as vertices
thickPolygon :: ([Point], Number) -> Picture

-- | A solid polygon with these points as vertices
solidPolygon :: [Point] -> Picture

-- | A thin rectangle, with this width and height
rectangle :: (Number, Number) -> Picture

-- | A solid rectangle, with this width and height
solidRectangle :: (Number, Number) -> Picture

-- | A thick rectangle, with this width and height and line width
thickRectangle :: (Number, Number, Number) -> Picture

-- | A thin circle, with this radius
circle :: Number -> Picture

-- | A solid circle, with this radius
solidCircle :: Number -> Picture

-- | A thick circle, with this radius and line width
thickCircle :: (Number, Number) -> Picture

-- | A thin arc, starting and ending at these angles, with this radius
arc :: (Number, Number, Number) -> Picture

-- | A solid sector of a circle (i.e., a pie slice) starting and ending at
--   these angles, with this radius
sector :: (Number, Number, Number) -> Picture

-- | A thick arc, starting and ending at these angles, with this radius and
--   line width
thickArc :: (Number, Number, Number, Number) -> Picture

-- | A piece of text
text :: Text -> Picture

-- | A styled piece of text
styledText :: (Text, Font, TextStyle) -> Picture

-- | A picture drawn entirely in this color.
colored :: (Picture, Color) -> Picture

-- | A picture drawn entirely in this color.
coloured :: (Picture, Color) -> Picture

-- | A picture drawn translated in these directions.
translated :: (Picture, Number, Number) -> Picture

-- | A picture scaled by these factors.
scaled :: (Picture, Number, Number) -> Picture

-- | A picture scaled by these factors.
dilated :: (Picture, Number, Number) -> Picture

-- | A picture rotated by this angle.
rotated :: (Picture, Number) -> Picture
pictures :: [Picture] -> Picture
(&) :: Picture -> Picture -> Picture

-- | A coordinate plane. Adding this to your pictures can help you measure
--   distances more accurately.
--   
--   Example:
--   
--   main = pictureOf(myPicture &amp; coordinatePlane) myPicture = ...
coordinatePlane :: Picture

-- | The CodeWorld logo.
codeWorldLogo :: Picture

-- | An event initiated by the user.
--   
--   Values of this type represent events that the user triggers when using
--   an interaction, defined with <tt>interactionOf</tt>.
--   
--   Key events describe the key as <a>Text</a>. Most keys are represented
--   by a single character text string, with the capital letter or other
--   symbol from the key. Keys that don't correspond to a single character
--   use longer names from the following list. Keep in mind that not all of
--   these keys appear on all keyboards.
--   
--   <ul>
--   <li>Up, Down, Left, and Right for the cursor keys.</li>
--   <li>F1, F2, etc. for function keys.</li>
--   <li>Backspace</li>
--   <li>Tab</li>
--   <li>Enter</li>
--   <li>Shift</li>
--   <li>Ctrl</li>
--   <li>Alt</li>
--   <li>Esc</li>
--   <li>PageUp</li>
--   <li>PageDown</li>
--   <li>End</li>
--   <li>Home</li>
--   <li>Insert</li>
--   <li>Delete</li>
--   <li>CapsLock</li>
--   <li>NumLock</li>
--   <li>ScrollLock</li>
--   <li>PrintScreen</li>
--   <li>Break</li>
--   <li>Separator</li>
--   <li>Cancel</li>
--   <li>Help</li>
--   </ul>
data Event
KeyPress :: !Text -> Event
KeyRelease :: !Text -> Event
MousePress :: !(MouseButton, Point) -> Event
MouseRelease :: !(MouseButton, Point) -> Event
MouseMovement :: !Point -> Event
data MouseButton :: *
LeftButton :: MouseButton
MiddleButton :: MouseButton
RightButton :: MouseButton
trace :: (a, Text) -> a
type Program = IO ()
drawingOf :: Picture -> Program
pictureOf :: Picture -> Program
animationOf :: (Number -> Picture) -> Program
simulationOf :: ([Number] -> world, (world, Number) -> world, world -> Picture) -> Program
interactionOf :: ([Number] -> world, (world, Number) -> world, (world, Event) -> world, world -> Picture) -> Program
